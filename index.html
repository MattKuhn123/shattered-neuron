<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shattered Neuron</title>
    <link href="./styles.css" rel="stylesheet" />
    <script src=https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js></script>
    <script src="./formula-output.js"></script>
    <script src="./submit-output-form.js"></script>
</head>

<body>
    <main class="surface surface-dark">
        <form is="submit-output-form" class="center-content">
            <section class="surface surface-light">
                <h2>Scout Report</h2>
                <label for="opponent-victory-points">Opponent Victory points: </label>
                <output id="opponent-victory-points" name="opponent-victory-points" class="input input-dark">0</output>
                <label for="opponent-remaining-forces">Opponent remaining forces: </label>
                <output id="opponent-remaining-forces" name="opponent-remaining-forces" class="input input-dark">1000</output>
                <label for="opponent-actions-output">Opponent activity...</p>
                <output id="opponent-actions-output"><samp id="opponent-actions"></samp></output>
            </section>
            <section class="surface surface-light">
                <h2>HQ</h2>
                <label for="player-victory-points">Victory Points: </label>
                <output id="player-victory-points" name="player-victory-points" class="input input-dark">0</output>
                <label for="player-remaining-forces">Remaining forces: </label>
                <output id="player-remaining-forces" name="player-remaining-forces" class="input input-dark">1000</output>
                <fieldset>
                    <legend>Force commitment</legend>
                    <label for="player-commit-forces">Forces</label>
                    <input id="player-commit-forces" type="number" name="player-commit-forces" class="input input-dark" required max="1" min="1"/>
                </fieldset>
                <button class="input input-dark">Commit</button>
            </section>
        </form>
    </main>
    <dialog class="surface surface-light">
        <h2>After Action Report</h2>
        <form method="dialog">
            <aside>
                Sir,<br>
                We commited <mark id="report-player-commitment"></mark> forces to the engagement.
                The opposition commited <mark id="report-opponent-commitment"></mark> forces.
                We <mark id="report-outcome"></mark> the engagement, and the victor gained <mark id="report-victory-points">1</mark> victory points.
            </aside>
            <button class="input input-dark">Confirm</button>
        </form>
    </dialog>
</body>
<script>
    elt = (id) => {
        return document.getElementById(id);
    }

    val = (id, value) => {
        const x = elt(id);
        if (value !== undefined) {
            if (x.tagName.toLowerCase() === "input") {
                x.value = value.toString();
            } else {
                x.textContent = value.toString();
            }
        } else {
            if (x.tagName.toLowerCase() === "input") {
                return Number(x.value);
            } else {
                return Number(x.textContent);
            }
        }

    }

    inc = (id, amount = 1) => val(id, val(id) + amount);

    playerRemainingForcesId = () => "player-remaining-forces";
    opponentRemainingForcesId = () => "opponent-remaining-forces";
    playerCommitForcesId = () => "player-commit-forces";
    playerVictoryPointsId = () => "player-victory-points";
    opponentVictoryPointsId = () => "opponent-victory-points";

    document.addEventListener("DOMContentLoaded", () => doEngagementCycle(engagementCycle()));

    engagementCycle = () => {
        return {
            playerVictory: false,
            opponentForces: 0,
            victoryPoints: 1,
            setUpGameState: async () => {
                const { params, isStart } = getInitState();
                params.forEach((v, k) => val(k, v));
                return isStart;
            },
            opponentTurn: async () => {
                this.opponentForces = await doOpponentAction(opponentActionAssignForces());
            },
            engage: async () => {
                inc(playerRemainingForcesId(), -val(playerCommitForcesId()));
                inc(opponentRemainingForcesId(), -this.opponentForces);

                this.playerVictory = val(playerCommitForcesId()) > this.opponentForces;
                if (this.playerVictory) {
                    inc(playerVictoryPointsId(), this.victoryPoints);
                } else {
                    inc(opponentVictoryPointsId(), this.victoryPoints);
                }
            },
            postEngagement: async () => {
                val("report-player-commitment", val(playerCommitForcesId()));
                val("report-opponent-commitment", this.opponentForces);
                val("report-outcome", `${this.playerVictory ? "won" : "lost"}`);
                val("report-victory-points", this.victoryPoints);
                document.querySelector("dialog").showModal();
            },
            setUpPlayerTurn: async () => {
                val(playerCommitForcesId(), 0);
                elt(playerCommitForcesId()).max = val(playerRemainingForcesId());
            },
            checkFinalState: async() => {
                // TODO : Check if the game is over
            }
        }
    }

    getInitState = () => {
        const params = new URLSearchParams(window.location.search);
        const isStart = params.size === 0;

        if (!params.has("player-remaining-forces")) {
            params.set("player-remaining-forces", "1000");
        }

        if (!params.has("opponent-remaining-forces")) {
            params.set("opponent-remaining-forces", "1000");
        }

        if (!params.has("player-victory-points")) {
            params.set("player-victory-points", "0");
        }

        if (!params.has("opponent-victory-points")) {
            params.set("opponent-victory-points", "0");
        }

        return { params, isStart };
    }

    doEngagementCycle = async (engagementCycle) => {
        document.querySelectorAll("input").forEach(x => x.setAttribute("readonly", true));
        document.querySelectorAll("button").forEach(x => x.setAttribute("disabled", true));

        const isStart = await engagementCycle.setUpGameState();
        if (!isStart) {
            await engagementCycle.opponentTurn();
            await engagementCycle.engage();
            await engagementCycle.postEngagement();
        }

        await engagementCycle.setUpPlayerTurn();
        await engagementCycle.checkFinalState();

        document.querySelectorAll("input").forEach(x => x.removeAttribute("readonly"));
        document.querySelectorAll("button").forEach(x => x.removeAttribute("disabled"));
    }

    opponentActionAssignForces = () => {
        return {
            startText: "Planning...",
            readyText: "Mobilizing...",
            fn: async () => {
                const forces = Math.floor(Math.random() * val(opponentRemainingForcesId()));
                return forces;
            }
        }
    }

    doOpponentAction = async (action) => {
        return new Promise((resolve) => {
            val("opponent-actions", action.startText);
            setTimeout(() => {
                val("opponent-actions", action.readyText);
                setTimeout(async () => {
                    val("opponent-actions", "");
                    const result = await action.fn();
                    resolve(result);
                }, 500)
            }, 1000);
        });
    }
</script>

</html>